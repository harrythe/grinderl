#summary Complete example: from test deployment to result analysis

Goal of this example is to write a complete documentation of _grinderl_ through a "real case" example.

* !!! work in progress !!! *

= Principles of grinderl =

  * Basic action in grinderl is a *task*, which is quite similar with a function, except that a task embed the function code, the arguments it will receive, and a description of the results it will give.
  * A *test* wrap a task to define how this task is run on one node: it embed notion of sequence/concurrency and the number of time the task is repeated.
  * A *scenario* describes then when and where some tests are run.


= Problem =

Here is an example:
  * Let's 2 Erlang nodes N1 and N2.
  * Let's F a function which behave as a server client (send one request and wait one result).
    * F takes one argument, which is a server.
    * F return 2 values which are the time to got the reply, and a server result.
  * 3 server S1, S2, S3 are running.
  * Goal is to run the function F (make a request) 10 times for each server, with an equitable load balancing.


= Implementation of the tests =

Let's create a task:
{{{
Task = #task{
    nick = "Run F on S1, S2, S3",
    task_fun = F,
    arglst = [
        {sequence, [S1, S2, S3]}
    ],
    result_spec = [
        {mean, evaltime},
        {count, servresult}
    ],
    mode = concurrent,
    repeat_n = 15 % 2 worker nodes * 15 function calls (3 servers, 10 requests each)
}).
}}}


= Run the tests =
{{{
erl> grinderl:add_nodes([N1, N2]).
erl> grinderl:run_task(Task).
}}}


= Get the result =
...




